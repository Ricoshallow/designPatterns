# 前端设计模式

## 什么是设计模式
设计模式是对软件设计开发过程中**反复**出现的某类问题的**通用**解决方案。学习设计模式更多的是理解各种模式的内在思想和解决的问题。

## 设计模式的类型
1. 结构型模式（Structural Patterns）： 通过识别系统中组件间的简单关系来简化系统的设计。
2. 创建型模式（Creational Patterns）： 处理对象的创建，根据实际情况使用合适的方式创建对象。常规的对象创建方式可能会导致设计上的问题，或增加设计的复杂度。创建型模式通过以某种方式控制对象的创建来解决问题。
3. 行为型模式（Behavioral Patterns）： 用于识别对象之间常见的交互模式并加以实现，如此，增加了这些交互的灵活性。

### 1.结构型模式（Structural Patterns）

-  外观模式（Facade Pattern）

    它为子系统中的一组接口提供一个统一的高层接口，使子系统更容使用。简而言之外观设计模式就是把多个子系统中复杂逻辑进行象，从而提供一个更统一、更简洁、更易用的API。

- 代理模式（Proxy Pattern）

    当访问一个对象本身的代价太高（比如太占内存、初始化时间太长等）或者需要增加额外的逻辑又不修改对象本身时便可以使用代理。代理三要素：
    1. Real Subject：真实对象
    2. Proxy：代理对象
    3. Subject接口：Real Subject 和 Proxy都需要实现的接口，这样Proxy才能被当成Real Subject的“替身”使用

### 2.创建型模式（Creational Patterns）

- 工厂模式（Factory Pattern）

    当构造函数过多不方便管理，且需要创建的对象之间存在某些关联（有同一个父类、实现同一个接口等）时，不妨使用工厂模式。工厂模式提供一种集中化、统一化的方式，避免了分散创建对象导致的代码重复、灵活性差的问题。

- 单例模式（Singleton Pattern）


### 3.行为型模式（Behavioral Patterns）
 
- 策略模式（Strategy Pattern）

    对象有某个行为，但是在不同的场景中，该行为有不同的实现算法。最常见的使用策略模式的场景如登录鉴权。优势：
    - 方便在运行时切换算法和策略
    - 代码更简洁，避免使用大量的条件判断
    - 关注分离，每个strategy类控制自己的算法逻辑，strategy和其使用者之间也相互独立

- 迭代器模式（Iterator Pattern）

    迭代器用于遍历容器（集合）并访问容器中的元素，而且无论容器的数据结构是什么（Array、Set、Map等），迭代器的接口都应该是一样的，都需要遵循迭代器协议。

    - 提供一致的遍历各种数据结构的方式，而不用了解数据的内部结构
    - 提供遍历容器（集合）的能力而无需改变容器的接口

- 观察者模式（Observer Pattern）

    观察者模式又称发布订阅模式（Publish/Subscribe Pattern）。被观察对象（subject）维护一组观察者（observer），当被观察对象状态改变时，通过调用观察者的某个方法将这些变化通知到观察者。三要素：

    - subscribe(): 接收一个观察者observer对象，使其订阅自己
    - unsubscribe(): 接收一个观察者observer对象，使其取消订阅自己
    - fire(): 触发事件，通知到所有观察者

- 中介者模式（Mediator Pattern）

    在中介者模式中，中介者（Mediator）包装了一系列对象相互作用的方式，使得这些对象不必直接相互作用，而是由中介者协调它们之间的交互，从而使它们可以松散偶合。当某些对象之间的作用发生改变时，不会立即影响其他的一些对象之间的作用，保证这些作用可以彼此独立的变化。

- 访问者模式（Visitor Pattern）

    访问者模式是一种将算法与对象结构分离的设计模式，通俗点讲就是：访问者模式让我们能够在不改变一个对象结构的前提下能够给该对象增加新的逻辑，新增的逻辑保存在一个独立的访问者对象中.要素:
    - Visitor Object：访问者对象，拥有一个 visit() 方法
    - Receiving Object：接收对象，拥有一个 accept() 方法
    - visit(receivingObj)：用于Visitor接收一个Receiving Object
    - accept(visitor)：用于Receving Object接收一个Visitor，并通过调用Visitor的 visit() 为其提供获取Receiving Object数据的能力
